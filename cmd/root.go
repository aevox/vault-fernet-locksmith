// Copyright © 2019 Marc Fouché
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
	"fmt"
	"io/ioutil"
	"os"
	"strings"

	"github.com/aevox/vault-fernet-locksmith/pkg/vault"

	log "github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

// Configuration holds all the configuration for locksmith
type Configuration struct {
	Vault        VaultConfiguration // Configuration
	Vaults       []VaultConfiguration
	Consul       ConsulConfiguration
	TTL          int              // Interval between each poll on vault
	SecretPath   string           // Path in vault for fernet-keys secret
	Health       bool             // Enable health endpoint
	HealthPeriod int              // Period between each health check in seconds
	Bootstrap    BootstrapOptions // Options needed to bootstrap secrets
}

// VaultConfiguration holds all the options to create a vault client
type VaultConfiguration struct {
	Address    string // Vault address
	Proxy      string // Path to proxy
	Token      string // Vault token used to identify with this vault
	TokenFile  string // Path to file containing vault token
	RenewToken bool   // Enable token renewal
}

// ConsulConfiguration holds all the options to create a vault client
type ConsulConfiguration struct {
	Address   string // Consul address
	Proxy     string // Proxy URL used to contact Consul
	Token     string // Consul token use to access consul to read configuration and write lockKey
	TokenFile string // Path to find Consul token
	Lock      bool   // Use consul lock system
	LockKey   string // What key is used for the consul lock system
}

// BootstrapOptions holds the extra options needed to bootstrap fernet keys
type BootstrapOptions struct {
	NumKeys int   // Number of fernet keys to create
	Period  int64 // Period between each key rotation
}

var (
	cfgFile string
	cfg     Configuration
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &cobra.Command{
	Use:   "vault-fernet-locksmith",
	Short: "Tool for fernet keys management in Vault.",
	Long: `vault-fernet-locksmith watches and rotates a list of fernet keys that are stored in Vault  as a secret.
The keys are stored with metadata indicating a period and date of creation.
Keys are URL-safe base64 encoded strings made from 256 bits of pseudorandom data generated by golang package crypto/rand.`,
	PersistentPreRun: func(cmd *cobra.Command, args []string) {
		if err := setUpLogs(viper.GetString("verbosity")); err != nil {
			log.Fatalf("Cannot set up log levels: %v", err)
		}
		log.Debugf("Configuration used: %v", viper.AllSettings())
	},
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

func init() {
	cobra.OnInitialize(initConfig)

	rootCmd.PersistentFlags().StringVarP(&cfgFile, "config", "c", "", "configuration file")
	rootCmd.PersistentFlags().String("vault-address", "https://127.0.0.1:8500", "Vault address")
	rootCmd.PersistentFlags().String("vault-proxy", "", "proxy URL used to contact Vault")
	rootCmd.PersistentFlags().String("vault-token", "", "Vault token used to authenticate with Vault")
	rootCmd.PersistentFlags().String("vault-token-file", "", "file containing the vault token used to authenticate with Vault")
	rootCmd.PersistentFlags().String("secret-path", "secret/fernet-keys", "path to the fernet-keys secret in primary Vault")
	rootCmd.PersistentFlags().StringP("verbosity", "v", log.InfoLevel.String(), "log level (debug, info, warn, error, fatal, panic)")

	viper.BindPFlag("vault.address", rootCmd.PersistentFlags().Lookup("vault-address"))
	viper.BindPFlag("vault.proxy", rootCmd.PersistentFlags().Lookup("vault-proxy"))
	viper.BindPFlag("vault.token", rootCmd.PersistentFlags().Lookup("vault-token"))
	viper.BindPFlag("vault.tokenFile", rootCmd.PersistentFlags().Lookup("vault-token-file"))
	viper.BindPFlag("secretPath", rootCmd.PersistentFlags().Lookup("secret-path"))
	viper.BindPFlag("verbosity", rootCmd.PersistentFlags().Lookup("verbosity"))
}

// initConfig reads in config file and ENV variables if set.
func initConfig() {
	viper.SetEnvPrefix("VFL")
	viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
	viper.AutomaticEnv() // read in environment variables that match

	if cfgFile != "" {
		// Use config file from the flag.
		viper.SetConfigFile(cfgFile)

		// If a config file is found, read it in.
		if err := viper.ReadInConfig(); err != nil {
			log.Fatalf("Cannot read configuration file: %s\n", err)
		}
	}
	if err := viper.Unmarshal(&cfg); err != nil {
		log.Fatalf("Cannot unmarshal config: %s", err)
	}
}

// createVaultClients create a list of Vault clients. It Makes sure we can contact
// every Vaults
func createVaultClients() ([]*vault.Vault, error) {
	var vaultConfigs []VaultConfiguration
	var vcs []*vault.Vault
	if len(cfg.Vaults) != 0 {
		vaultConfigs = cfg.Vaults
	} else {
		vaultConfigs = []VaultConfiguration{cfg.Vault}
	}
	log.Debug("Creating Vault clients")
	for _, vaultConfig := range vaultConfigs {
		vaultClient, err := vault.NewClient(vaultConfig.Address, vaultConfig.Proxy, vaultConfig.RenewToken)
		if err != nil {
			log.Fatalf("Failed to create vault client for %s: %v", vaultConfig.Address, err)
		}

		// Set Vault client token
		var vaultToken string
		if vaultConfig.Token != "" {
			vaultToken = vaultConfig.Token
		} else if vaultConfig.TokenFile != "" {
			data, err := ioutil.ReadFile(vaultConfig.TokenFile)
			if err != nil {
				log.Fatalf("Cannot read vault token file: %v", err)
			}
			vaultToken = string(data)
		} else {
			log.Fatalf("No vault token provided for Vault %s", vaultClient.Client.Address())
		}
		vaultClient.Client.SetToken(vaultToken)
		vcs = append(vcs, vaultClient)
	}
	return vcs, nil
}

//setUpLogs set the log output and the log level
func setUpLogs(level string) error {
	lvl, err := log.ParseLevel(level)
	if err != nil {
		return err
	}
	log.SetLevel(lvl)
	return nil
}
